name: Deploy to EC2 via ECR

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-20.04

    steps:
      # 1  Checkout & SSH key
      - uses: actions/checkout@v3

      - name: Decode EC2 SSH key
        run: |
          echo "${{ secrets.EC2_SSH_KEY_B64 }}" | base64 -d > /tmp/chatbot_sa_key.pem
          chmod 600 /tmp/chatbot_sa_key.pem

      - name: Test SSH connection
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "echo 'SSH connection successful'"

      # 2  Optional debug â€“ sitemap from EC2
      - name: Test downloading Gringo sitemap from EC2
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "curl -s -o /dev/null -w 'HTTP=%{http_code}\n' -A 'Mozilla/5.0' https://gringo.co.il/sitemap.xml || true"

      # 3  AWS credentials (env-vars only)
      - uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      # 4  *** Install AWS CLI (needed for act) ***
      - name: Install AWS CLI
        run: |
          curl -sSL https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip -o awscliv2.zip
          unzip -q awscliv2.zip
          sudo ./aws/install --update
          aws --version

      # 5  Image tag outputs
      - id: vars
        run: |
          echo "BOT_IMAGE=${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}_bot:latest"         >> $GITHUB_OUTPUT
          echo "CRAWLER_IMAGE=${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}_crawler:latest" >> $GITHUB_OUTPUT
          echo "PARSER_IMAGE=${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}_parser:latest"   >> $GITHUB_OUTPUT
          echo "API_IMAGE=${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY }}_api:latest"         >> $GITHUB_OUTPUT

      # 6  Ensure ECR repositories exist
      - name: Ensure ECR repositories exist
        env: { AWS_PAGER: "" }
        run: |
          for repo in bot crawler parser api; do
            full="${{ secrets.ECR_REPOSITORY }}_${repo}"
            aws ecr describe-repositories --repository-names "$full" --region ${{ secrets.AWS_REGION }} \
              || aws ecr create-repository --repository-name "$full" --region ${{ secrets.AWS_REGION }}
          done

      - name: Log in to Amazon ECR
        run: |
          aws ecr get-login-password | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}

      # 7  Download sitemap into build context
      - name: Download sitemap for build
        run: |
          mkdir -p ./crawlers/gringo_fetcher
          curl -L -A "Mozilla/5.0" -o ./crawlers/gringo_fetcher/sitemap.xml \
            https://gringo.co.il/sitemap.xml || true

      # 8  Build & push crawler image
      - name: Build and push crawler image
        uses: docker/build-push-action@v3
        with:
          context: ./crawlers/gringo_fetcher
          push: true
          tags: ${{ steps.vars.outputs.CRAWLER_IMAGE }}
          build-args: SITEMAP_XML=sitemap.xml
          cache-from: type=registry,ref=${{ steps.vars.outputs.CRAWLER_IMAGE }}
          cache-to: type=inline

      # 9  Build & push other images
      - name: Build and push bot image
        uses: docker/build-push-action@v3
        with:
          context: ./bot
          push: true
          tags: ${{ steps.vars.outputs.BOT_IMAGE }}

      - name: Build and push parser image
        uses: docker/build-push-action@v3
        with:
          context: ./crawlers/gringo_parser
          push: true
          tags: ${{ steps.vars.outputs.PARSER_IMAGE }}

      - name: Build and push API image
        uses: docker/build-push-action@v3
        with:
          context: ./rag_api
          push: true
          tags: ${{ steps.vars.outputs.API_IMAGE }}

      # 10  Free disk on EC2
      - name: Prune Docker on EC2
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "docker system prune -af && docker volume prune -f && docker builder prune -af"

      # 11  Upload compose & env
      - name: Prepare EC2 folder
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "sudo mkdir -p /home/${{ secrets.EC2_USER }}/chatbot_sa && \
             sudo chown -R ${{ secrets.EC2_USER }}:${{ secrets.EC2_USER }} /home/${{ secrets.EC2_USER }}/chatbot_sa"

      - name: Upload docker-compose.yml
        run: |
          scp -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            docker-compose.yml \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/chatbot_sa/docker-compose.yml

      - name: Upload .env
        run: |
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" > /tmp/remote.env
          scp -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            /tmp/remote.env \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/chatbot_sa/.env

      # 12  Ensure Docker Compose on EC2
      - name: Ensure Docker Compose >= v2.20.2 on EC2
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            'if ! command -v docker-compose >/dev/null || [ "$(docker-compose version --short)" != "2.20.2" ]; then
               sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-linux-x86_64" \
                 -o /usr/local/bin/docker-compose && sudo chmod +x /usr/local/bin/docker-compose;
             fi'

      # 13  Compose up
      - name: Docker Compose up
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "cd /home/${{ secrets.EC2_USER }}/chatbot_sa && \
             aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }} && \
             docker-compose pull && docker-compose up -d"

      # 14  Open ports (non-fatal)
      - name: Configure EC2 Security Group
        run: |
          AWS_PAGER="" aws ec2 authorize-security-group-ingress --group-name default --protocol tcp --port 8000 --cidr 0.0.0.0/0 || true
          AWS_PAGER="" aws ec2 authorize-security-group-ingress --group-name default --protocol tcp --port 8001 --cidr 0.0.0.0/0 || true

      # 15  Verify deployment
      - name: Verify deployment
        run: |
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "docker ps"
          ssh -i /tmp/chatbot_sa_key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "curl -f http://localhost:8000/health"
          curl -f "http://${{ secrets.EC2_HOST }}:8000/health"
